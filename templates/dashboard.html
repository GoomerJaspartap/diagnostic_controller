{% extends 'base.html' %}
{% block title %}Dashboard - Diagnostic Controller{% endblock %}
{% block content %}
<div class="row justify-content-center">
    <div class="col-md-12">
        <!-- Controls Section -->
        <div class="row mb-3">
            <!-- Chamber Filter Dropdown -->
            <div class="col-12 col-md-3">
                <label for="chamberFilter" class="form-label">Filter by Chamber:</label>
                <select id="chamberFilter" class="form-select">
                    <option value="all">All Chambers</option>
                    {% for chamber_name, chamber_data in codes_by_room.items() %}
                        <option value="{{ chamber_data.room_id }}">{{ chamber_name }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <!-- Contact Stats -->
            <div class="col-12 col-md-4">
                <label class="form-label">&nbsp;</label>
                <div class="d-flex">
                    <a href="{{ url_for('contacts') }}" style="text-decoration: none;">
                        <div class="d-flex gap-2">
                            <span class="badge bg-info" style="font-size: 1.1em; padding: 8px 12px; cursor: pointer;">
                                <i class="fas fa-envelope me-1"></i> Email: {{ email_enabled }}/{{ total_contacts }}
                            </span>
                            <span class="badge bg-info" style="font-size: 1.1em; padding: 8px 12px; cursor: pointer;">
                                <i class="fas fa-phone me-1"></i> SMS: {{ sms_enabled }}/{{ total_contacts }}
                            </span>
                        </div>
                    </a>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="col-12 col-md-5">
                <label class="form-label">&nbsp;</label>
                <div class="d-flex gap-2">
                    <button id="readNowBtn" class="btn btn-primary">
                        <i class="fas fa-sync-alt"></i> Read Modbus Now
                    </button>
                    <button id="resetHistoryBtn" class="btn btn-warning">
                        <i class="fas fa-history"></i> Reset All History
                    </button>
                </div>
            </div>
        </div>

        <!-- Notification Center -->
        <div id="notification-center">
            {% if notifications and notifications|length > 0 %}
            <div class="alert alert-warning mb-4">
                <strong>Notification Center:</strong>
                <ul class="mb-0" id="notification-list">
                    {% for n in notifications %}
                        <li>
                            <strong>{{ n[0] }}</strong> ({{ n[1] }}) - <span {% if n[2] == 'Fail' %}style="color: red; font-weight: bold;"{% elif n[2] == 'No Status' %}style="color: orange; font-weight: bold;"{% else %}style="font-weight: bold;"{% endif %}>{{ n[2] }}</span>
                            {% if n[3] %} | Last Failure: {{ n[3] }}{% endif %}
                        </li>
                    {% endfor %}
                </ul>
            </div>
            {% endif %}
        </div>

        <!-- Diagnostics by Chamber -->
        {% for chamber_name, chamber_data in codes_by_room.items() %}
        <div class="card shadow p-4 mb-4" data-room-id="{{ chamber_data.room_id }}">
            <h4 style="color: #003366;">
                <i class="fas fa-building me-2"></i>{{ chamber_name }}
                {% if chamber_data.room_id %}
                <a href="{{ url_for('rooms') }}" class="btn btn-sm btn-outline-secondary ms-2">
                    <i class="fas fa-cog"></i> Manage
                </a>
                {% endif %}
            </h4>
            
            <!-- Temperature Diagnostics for this chamber -->
            {% if chamber_data.temp %}
            <h5 style="color: #003366; margin-top: 20px; margin-bottom: 15px;">
                <i class="fas fa-thermometer-half me-2"></i>Temperature Diagnostics
            </h5>
            <div class="table-responsive mb-4">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>Description</th>
                            <th>Current Value</th>
                            <th>State</th>
                            <th>Fault Type</th>
                            <th>Last Failure</th>
                            <th>History</th>
                            <th>Last Read</th>
                            <th>Graph</th>
                        </tr>
                    </thead>
                    <tbody id="temp-codes-body-{{ chamber_data.room_id or 'unassigned' }}">
                        {% for code in chamber_data.temp %}
                        <tr {% if code[2] == 'Pass' %}style="background-color: #d4edda !important;"{% elif code[2] == 'Fail' %}style="background-color: #f44336 !important; color: #fff;"{% elif code[2] == 'No Status' %}style="background-color: #ffe066 !important;"{% endif %}>
                            <td data-label="Code">{{ code[0] }}</td>
                            <td data-label="Description">{{ code[1] }}</td>
                            <td data-label="Current Value">{{ code[7] if code[7] is not none else 'N/A' }} {{ code[6] or '' }}</td>
                            <td data-label="State"><strong style="{% if code[2] == 'Pass' %}color: #28a745;{% elif code[2] == 'Fail' %}color: #dc3545;{% else %}color: #ffc107;{% endif %}">{{ code[2] }}</strong></td>
                            <td data-label="Fault Type">{% if code[2] == 'Fail' and code[11] %}{% if 'Over' in code[11] %}<span class="badge bg-danger"><i class="fas fa-arrow-up me-1"></i>{{ code[11] }}</span>{% elif 'Under' in code[11] %}<span class="badge bg-danger"><i class="fas fa-arrow-down me-1"></i>{{ code[11] }}</span>{% else %}<span class="badge bg-danger">{{ code[11] }}</span>{% endif %}{% elif code[2] == 'Pass' %}<span class="badge bg-success">Pass</span>{% else %}<span class="badge bg-secondary">N/A</span>{% endif %}</td>
                            <td data-label="Last Failure">{{ code[3] }}</td>
                            <td data-label="History">{{ code[4] }}</td>
                            <td data-label="Last Read">{{ code[8] if code[8] else 'Never' }}</td>
                            <td data-label="Graph">
                                <button class="btn btn-sm btn-outline-info" onclick="showDiagnosticGraph('{{ code[0] }}', '{{ code[1] }}')">
                                    <i class="fas fa-chart-line"></i> Graph
                                </button>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            {% endif %}
            
            <!-- Humidity Diagnostics for this chamber -->
            {% if chamber_data.humidity %}
            <h5 style="color: #003366; margin-top: 20px; margin-bottom: 15px;">
                <i class="fas fa-tint me-2"></i>Humidity Diagnostics
            </h5>
            <div class="table-responsive">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>Description</th>
                            <th>Current Value</th>
                            <th>State</th>
                            <th>Fault Type</th>
                            <th>Last Failure</th>
                            <th>History</th>
                            <th>Last Read</th>
                            <th>Graph</th>
                        </tr>
                    </thead>
                    <tbody id="humidity-codes-body-{{ chamber_data.room_id or 'unassigned' }}">
                        {% for code in chamber_data.humidity %}
                        <tr {% if code[2] == 'Pass' %}style="background-color: #d4edda !important;"{% elif code[2] == 'Fail' %}style="background-color: #f44336 !important; color: #fff;"{% elif code[2] == 'No Status' %}style="background-color: #ffe066 !important;"{% endif %}>
                            <td data-label="Code">{{ code[0] }}</td>
                            <td data-label="Description">{{ code[1] }}</td>
                            <td data-label="Current Value">{{ code[7] if code[7] is not none else 'N/A' }} {{ code[6] or '' }}</td>
                            <td data-label="State"><strong style="{% if code[2] == 'Pass' %}color: #28a745;{% elif code[2] == 'Fail' %}color: #dc3545;{% else %}color: #ffc107;{% endif %}">{{ code[2] }}</strong></td>
                            <td data-label="Fault Type">{% if code[2] == 'Fail' and code[11] %}{% if 'Over' in code[11] %}<span class="badge bg-danger"><i class="fas fa-arrow-up me-1"></i>{{ code[11] }}</span>{% elif 'Under' in code[11] %}<span class="badge bg-danger"><i class="fas fa-arrow-down me-1"></i>{{ code[11] }}</span>{% else %}<span class="badge bg-danger">{{ code[11] }}</span>{% endif %}{% elif code[2] == 'Pass' %}<span class="badge bg-success">Pass</span>{% else %}<span class="badge bg-secondary">N/A</span>{% endif %}</td>
                            <td data-label="Last Failure">{{ code[3] }}</td>
                            <td data-label="History">{{ code[4] }}</td>
                            <td data-label="Last Read">{{ code[8] if code[8] else 'Never' }}</td>
                            <td data-label="Graph">
                                <button class="btn btn-sm btn-outline-info" onclick="showDiagnosticGraph('{{ code[0] }}', '{{ code[1] }}')">
                                    <i class="fas fa-chart-line"></i> Graph
                                </button>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            {% endif %}
            
            {% if not chamber_data.temp and not chamber_data.humidity %}
            <div class="text-center text-muted py-4">
                <i class="fas fa-info-circle fa-2x mb-3"></i>
                <p>No diagnostic codes assigned to this chamber yet.</p>
                <a href="{{ url_for('diagnostic_codes') }}" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Add Diagnostic Code
                </a>
            </div>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>

<!-- Add Plotly.js CDN -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<script>
function applyChamberFilter() {
    const selectedRoomId = document.getElementById('chamberFilter').value;
    document.querySelectorAll('.card.shadow.p-4.mb-4').forEach(card => {
        const roomId = card.getAttribute('data-room-id');
        if (selectedRoomId === 'all' || roomId === selectedRoomId) {
            card.style.display = '';
        } else {
            card.style.display = 'none';
        }
    });
}

const chamberFilter = document.getElementById('chamberFilter');
chamberFilter.addEventListener('change', applyChamberFilter);

// Add read now functionality
document.getElementById('readNowBtn').addEventListener('click', function() {
    const selectedChamber = document.getElementById('chamberFilter').value;
    const roomId = selectedChamber === 'all' ? 'all' : selectedChamber;
    
    // Disable button and show loading state
    const btn = this;
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Reading...';
    
    fetch('/api/read_now', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            room_id: roomId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Immediately update the display
            updateDiagnostics();
            // Show success message
            alert('Modbus data read successfully!');
        } else {
            alert('Error reading Modbus data: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error reading Modbus data. Please try again.');
    })
    .finally(() => {
        // Re-enable button and restore original text
        btn.disabled = false;
        btn.innerHTML = originalText;
    });
});

function updateDiagnostics() {
    fetch('/api/diagnostics')
        .then(response => response.json())
        .then(data => {
            // Update the entire dashboard with chamber-based data
            const dashboardContainer = document.querySelector('.col-md-12');
            
            // Remove all existing chamber diagnostic cards
            dashboardContainer.querySelectorAll('.card.shadow.p-4.mb-4').forEach(card => card.remove());
            
            // Add new chamber-based diagnostic sections
            Object.entries(data.codes_by_room).forEach(([chamberName, chamberData]) => {
                const chamberCard = document.createElement('div');
                chamberCard.className = 'card shadow p-4 mb-4';
                chamberCard.setAttribute('data-room-id', chamberData.room_id);
                
                let cardContent = `
                    <h4 style="color: #003366;">
                        <i class="fas fa-building me-2"></i>${chamberName}
                        ${chamberData.room_id ? `<a href="/rooms" class="btn btn-sm btn-outline-secondary ms-2"><i class="fas fa-cog"></i> Manage</a>` : ''}
                    </h4>
                `;
                
                // Add temperature diagnostics
                if (chamberData.temp && chamberData.temp.length > 0) {
                    cardContent += `
                        <h5 style="color: #003366; margin-top: 20px; margin-bottom: 15px;">
                            <i class="fas fa-thermometer-half me-2"></i>Temperature Diagnostics
                        </h5>
                        <div class="table-responsive mb-4">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Code</th>
                                        <th>Description</th>
                                        <th>Current Value</th>
                                        <th>State</th>
                                        <th>Fault Type</th>
                                        <th>Last Failure</th>
                                        <th>History</th>
                                        <th>Last Read</th>
                                        <th>Graph</th>
                                    </tr>
                                </thead>
                                <tbody id="temp-codes-body-${chamberData.room_id || 'unassigned'}">
                    `;
                    
                    chamberData.temp.forEach(code => {
                        const bgColor = code[2] === 'Pass' ? '#d4edda' : code[2] === 'Fail' ? '#f44336' : '#ffe066';
                        const textColor = code[2] === 'Pass' ? '#28a745' : code[2] === 'Fail' ? '#dc3545' : '#ffc107';
                        const faultType = code[2] === 'Fail' && code[11] ? code[11] : code[2] === 'Pass' ? 'Pass' : 'N/A';
                        const faultTypeClass = code[2] === 'Fail' && code[11] ? 'bg-danger' : code[2] === 'Pass' ? 'bg-success' : 'bg-secondary';
                        let faultTypeHtml = '';
                        if (code[2] === 'Fail' && code[11]) {
                            if (code[11].includes('Over')) {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}"><i class='fas fa-arrow-up me-1'></i>${code[11]}</span>`;
                            } else if (code[11].includes('Under')) {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}"><i class='fas fa-arrow-down me-1'></i>${code[11]}</span>`;
                            } else {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}">${code[11]}</span>`;
                            }
                        } else if (code[2] === 'Pass') {
                            faultTypeHtml = `<span class="badge ${faultTypeClass}">Pass</span>`;
                        } else {
                            faultTypeHtml = `<span class="badge ${faultTypeClass}">N/A</span>`;
                        }
                        cardContent += `
                            <tr style="background-color: ${bgColor} !important; ${code[2] === 'Fail' ? 'color: #fff;' : ''}">
                                <td data-label="Code">${code[0]}</td>
                                <td data-label="Description">${code[1]}</td>
                                <td data-label="Current Value">${code[7] !== null ? code[7] + ' ' + (code[6] || '') : 'N/A'}</td>
                                <td data-label="State"><strong style="color: ${textColor};">${code[2]}</strong></td>
                                <td data-label="Fault Type">${faultTypeHtml}</td>
                                <td data-label="Last Failure">${code[3] || ''}</td>
                                <td data-label="History">${code[4]}</td>
                                <td data-label="Last Read">${code[8] || 'Never'}</td>
                                <td data-label="Graph">
                                    <button class="btn btn-sm btn-outline-info" onclick="showDiagnosticGraph('${code[0]}', '${code[1].replace(/'/g, "\\'")}')">
                                        <i class="fas fa-chart-line"></i> Graph
                                    </button>
                                </td>
                            </tr>
                        `;
                    });
                    
                    cardContent += `
                                </tbody>
                            </table>
                        </div>
                    `;
                }
                
                // Add humidity diagnostics
                if (chamberData.humidity && chamberData.humidity.length > 0) {
                    cardContent += `
                        <h5 style="color: #003366; margin-top: 20px; margin-bottom: 15px;">
                            <i class="fas fa-tint me-2"></i>Humidity Diagnostics
                        </h5>
                        <div class="table-responsive">
                            <table class="table">
                                <thead>
                                    <tr>
                                        <th>Code</th>
                                        <th>Description</th>
                                        <th>Current Value</th>
                                        <th>State</th>
                                        <th>Fault Type</th>
                                        <th>Last Failure</th>
                                        <th>History</th>
                                        <th>Last Read</th>
                                        <th>Graph</th>
                                    </tr>
                                </thead>
                                <tbody id="humidity-codes-body-${chamberData.room_id || 'unassigned'}">
                    `;
                    
                    chamberData.humidity.forEach(code => {
                        const bgColor = code[2] === 'Pass' ? '#d4edda' : code[2] === 'Fail' ? '#f44336' : '#ffe066';
                        const textColor = code[2] === 'Pass' ? '#28a745' : code[2] === 'Fail' ? '#dc3545' : '#ffc107';
                        const faultType = code[2] === 'Fail' && code[11] ? code[11] : code[2] === 'Pass' ? 'Pass' : 'N/A';
                        const faultTypeClass = code[2] === 'Fail' && code[11] ? 'bg-danger' : code[2] === 'Pass' ? 'bg-success' : 'bg-secondary';
                        let faultTypeHtml = '';
                        if (code[2] === 'Fail' && code[11]) {
                            if (code[11].includes('Over')) {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}"><i class='fas fa-arrow-up me-1'></i>${code[11]}</span>`;
                            } else if (code[11].includes('Under')) {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}"><i class='fas fa-arrow-down me-1'></i>${code[11]}</span>`;
                            } else {
                                faultTypeHtml = `<span class="badge ${faultTypeClass}">${code[11]}</span>`;
                            }
                        } else if (code[2] === 'Pass') {
                            faultTypeHtml = `<span class="badge ${faultTypeClass}">Pass</span>`;
                        } else {
                            faultTypeHtml = `<span class="badge ${faultTypeClass}">N/A</span>`;
                        }
                        cardContent += `
                            <tr style="background-color: ${bgColor} !important; ${code[2] === 'Fail' ? 'color: #fff;' : ''}">
                                <td data-label="Code">${code[0]}</td>
                                <td data-label="Description">${code[1]}</td>
                                <td data-label="Current Value">${code[7] !== null ? code[7] + ' ' + (code[6] || '') : 'N/A'}</td>
                                <td data-label="State"><strong style="color: ${textColor};">${code[2]}</strong></td>
                                <td data-label="Fault Type">${faultTypeHtml}</td>
                                <td data-label="Last Failure">${code[3] || ''}</td>
                                <td data-label="History">${code[4]}</td>
                                <td data-label="Last Read">${code[8] || 'Never'}</td>
                                <td data-label="Graph">
                                    <button class="btn btn-sm btn-outline-info" onclick="showDiagnosticGraph('${code[0]}', '${code[1].replace(/'/g, "\\'")}')">
                                        <i class="fas fa-chart-line"></i> Graph
                                    </button>
                                </td>
                            </tr>
                        `;
                    });
                    
                    cardContent += `
                                </tbody>
                            </table>
                        </div>
                    `;
                }
                
                // Add empty state if no diagnostics
                if ((!chamberData.temp || chamberData.temp.length === 0) && (!chamberData.humidity || chamberData.humidity.length === 0)) {
                    cardContent += `
                        <div class="text-center text-muted py-4">
                            <i class="fas fa-info-circle fa-2x mb-3"></i>
                            <p>No diagnostic codes assigned to this chamber yet.</p>
                            <a href="/diagnostic_codes" class="btn btn-primary">
                                <i class="fas fa-plus"></i> Add Diagnostic Code
                            </a>
                        </div>
                    `;
                }
                
                chamberCard.innerHTML = cardContent;
                
                // Insert the chamber card before the script tag
                const scriptTag = dashboardContainer.querySelector('script');
                dashboardContainer.insertBefore(chamberCard, scriptTag);
            });
            
            // Update notifications
            const notificationCenter = document.getElementById('notification-center');
            if (data.notifications && data.notifications.length > 0) {
                // Build a map from code to chamber name
                const codeToChamber = {};
                Object.entries(data.codes_by_room).forEach(([chamberName, chamberData]) => {
                    ['temp', 'humidity'].forEach(type => {
                        (chamberData[type] || []).forEach(code => {
                            codeToChamber[code[0]] = chamberName;
                        });
                    });
                });
                notificationCenter.innerHTML = `
                    <div class="alert alert-warning mb-4">
                        <strong>Notification Center:</strong>
                        <ul class="mb-0" id="notification-list">
                            ${data.notifications.map(n => `
                                <li>
                                    <strong>${n[0]}</strong> (${n[1]}) in <strong>Chamber: ${codeToChamber[n[0]] || 'Unassigned'}</strong> - 
                                    <span style="${n[2] === 'Fail' ? 'color: red; font-weight: bold;' : 
                                                 n[2] === 'No Status' ? 'color: orange; font-weight: bold;' : 
                                                 'font-weight: bold;'}">${n[2]}</span>
                                    ${n[3] ? ` | Last Failure: ${n[3]}` : ''}
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            } else {
                notificationCenter.innerHTML = '';
            }
            applyChamberFilter(); // Re-apply filter after updating cards
        })
        .catch(error => {
            console.error('Error updating diagnostics:', error);
        });
}

// Add reset history functionality
document.getElementById('resetHistoryBtn').addEventListener('click', function() {
    if (confirm('Are you sure you want to reset all diagnostic code histories? This will clear all failure records and set states to "No Status".')) {
        fetch('/api/reset_history', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Immediately update the display
                updateDiagnostics();
                // Show success message
                alert('History reset successfully!');
            } else {
                alert('Error resetting history: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error resetting history. Please try again.');
        });
    }
});

// Update every second
setInterval(updateDiagnostics, 1000);

// Global variables for auto-updating graph
let currentGraphCode = null;
let currentGraphModal = null;
let graphUpdateInterval = null;
let lastGraphData = null;

// Global variable to track trace visibility by name
if (!window.traceVisibilityState) window.traceVisibilityState = {};

// Graph functionality
function showDiagnosticGraph(code, description) {
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal fade';
    modal.id = 'graphModal';
    modal.setAttribute('tabindex', '-1');
    modal.setAttribute('aria-labelledby', 'graphModalLabel');
    modal.setAttribute('aria-hidden', 'true');
    
    modal.innerHTML = `
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="graphModalLabel">Diagnostic Graph: ${code} - ${description}</h5>
                    <button type="button" class="btn btn-outline-secondary btn-sm me-2" id="fullscreenGraphBtn" title="Fullscreen"><i class="fas fa-expand"></i></button>
                    <button type="button" class="btn btn-outline-secondary btn-sm me-2" id="autoUpdateToggleBtn" title="Auto Update"><i class="fas fa-sync-alt"></i></button>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="graphContainer" style="height: 500px; width: 100%; min-width: 300px; min-height: 300px;"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    `;
    
    // Add modal to body
    document.body.appendChild(modal);
    
    // Show modal
    const modalInstance = new bootstrap.Modal(modal);
    modalInstance.show();
    
    // Store current graph info for auto-updating
    currentGraphCode = code;
    currentGraphModal = modal;
    
    // Load graph data
    loadGraphData(code, modal);
    
    // Start auto-updating
    startGraphAutoUpdate();
    
    // Fullscreen button functionality
    modal.querySelector('#fullscreenGraphBtn').onclick = function() {
        const graphContainer = modal.querySelector('#graphContainer');
        if (!document.fullscreenElement) {
            graphContainer.requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    };
    
    // Auto-update toggle button functionality
    const autoUpdateBtn = modal.querySelector('#autoUpdateToggleBtn');
    // Start with auto-update active
    autoUpdateBtn.innerHTML = '<i class="fas fa-stop"></i>';
    autoUpdateBtn.title = 'Stop Auto Update';
    autoUpdateBtn.classList.remove('btn-outline-secondary');
    autoUpdateBtn.classList.add('btn-success');
    
    autoUpdateBtn.onclick = function() {
        if (graphUpdateInterval) {
            stopGraphAutoUpdate();
            autoUpdateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            autoUpdateBtn.title = 'Auto Update';
            autoUpdateBtn.classList.remove('btn-success');
            autoUpdateBtn.classList.add('btn-outline-secondary');
        } else {
            startGraphAutoUpdate();
            autoUpdateBtn.innerHTML = '<i class="fas fa-stop"></i>';
            autoUpdateBtn.title = 'Stop Auto Update';
            autoUpdateBtn.classList.remove('btn-outline-secondary');
            autoUpdateBtn.classList.add('btn-success');
        }
    };
    
    // Clean up modal when hidden
    modal.addEventListener('hidden.bs.modal', function() {
        stopGraphAutoUpdate();
        currentGraphCode = null;
        currentGraphModal = null;
        lastGraphData = null;
        document.body.removeChild(modal);
    });
}

function startGraphAutoUpdate() {
    if (graphUpdateInterval) {
        clearInterval(graphUpdateInterval);
    }
    // Update every 2 seconds
    graphUpdateInterval = setInterval(() => {
        if (currentGraphCode && currentGraphModal) {
            updateGraphData();
        }
    }, 2000);
}

function stopGraphAutoUpdate() {
    if (graphUpdateInterval) {
        clearInterval(graphUpdateInterval);
        graphUpdateInterval = null;
    }
}

function updateGraphData() {
    if (!currentGraphCode || !currentGraphModal) return;
    
    console.log('Updating graph data for:', currentGraphCode);
    
    fetch(`/api/diagnostic_graph/${currentGraphCode}`)
        .then(response => response.json())
        .then(data => {
            console.log('Graph data response:', data);
            if (data.success) {
                updateGraphWithNewData(data.data);
            } else {
                console.log('Graph data error:', data.error);
            }
        })
        .catch(error => {
            console.error('Error updating graph data:', error);
        });
}

function loadGraphData(code, modal) {
    fetch(`/api/diagnostic_graph/${code}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                createGraph(data.data, modal);
            } else {
                document.getElementById('graphContainer').innerHTML = `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        ${data.error || 'Failed to load graph data'}
                    </div>
                `;
            }
        })
        .catch(error => {
            console.error('Error loading graph data:', error);
            document.getElementById('graphContainer').innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle"></i>
                    Error loading graph data. Please try again.
                </div>
            `;
        });
}

function toLocalString(date) {
    // Returns a string in the user's local time, e.g. '2024-06-15 08:20:00', strips GMT/UTC/Z
    return date.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    }).replace(/,| GMT.*|\s*GMT.*|\s*UTC.*|\s*Z$/, '').trim();
}

function parseAsUTC(timestamp) {
    // Ensures the timestamp is parsed as UTC, even if no Z is present
    if (!timestamp.endsWith('Z')) {
        return new Date(timestamp + 'Z');
    }
    return new Date(timestamp);
}

// Helper to shift a date by -4 hours and return ISO string (for America/New_York, UTC-4)
function toLocalISOString(date) {
    return new Date(date.getTime() - 4 * 60 * 60 * 1000).toISOString();
}

function createGraph(data, modal) {
    const container = document.getElementById('graphContainer');
    
    if (data.start_value === null || data.start_value === undefined || 
        data.target_value === null || data.target_value === undefined || 
        data.time_to_achieve === null || data.time_to_achieve === undefined || 
        data.enabled_time === null || data.enabled_time === undefined) {
        container.innerHTML = `
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i>
                No diagnostic parameters available for graphing. This diagnostic may not be enabled or configured.
            </div>
        `;
        return;
    }
    
    // Prepare time window in local time
    const startTime = parseAsUTC(data.enabled_time);
    const timeToAchieve = data.time_to_achieve;
    const now = new Date();
    
    // Start the graph at enabled time and extend to show all data
    let endTime = startTime;
    if (data.data_points && data.data_points.length > 0) {
        const latestPoint = data.data_points[data.data_points.length - 1];
        if (latestPoint.timestamp) {
            const latestPointTime = parseAsUTC(latestPoint.timestamp);
            endTime = new Date(Math.max(latestPointTime.getTime(), now.getTime()));
        }
    }
    
    // Always extend at least 5 minutes beyond the latest data point
    endTime = new Date(endTime.getTime() + 5 * 60 * 1000);
    
    // Generate expected/threshold curves (matching trial.py logic)
    const timePoints = [];
    const expectedValues = [];
    const upperThreshold = [];
    const lowerThreshold = [];
    const timeStep = Math.max(1, Math.floor((endTime.getTime() - startTime.getTime()) / 1000 / 100));
    
    // Calculate slope and intercept (matching trial.py logic)
    const m = (data.target_value - data.start_value) / timeToAchieve;
    const startTimeSeconds = startTime.getTime() / 1000;
    const b = data.start_value - m * startTimeSeconds;
    
    const minBound = Math.min(data.start_value, data.target_value);
    const maxBound = Math.max(data.start_value, data.target_value);
    // Generate points from start time to end time (extending beyond diagnostic duration)
    for (let t = 0; t <= (endTime.getTime() - startTime.getTime()) / 1000; t += timeStep) {
        const timestamp = new Date(startTime.getTime() + t * 1000);
        timePoints.push(toLocalISOString(timestamp)); // Use shifted ISO string for Plotly date axis
        // Calculate expected value using trial.py logic
        const currentTimeSeconds = timestamp.getTime() / 1000;
        let expectedValue;
        if (currentTimeSeconds < startTimeSeconds) {
            expectedValue = data.start_value;
        } else if (currentTimeSeconds >= startTimeSeconds + timeToAchieve) {
            // After diagnostic duration, maintain target value (flat line)
            expectedValue = data.target_value;
        } else {
            expectedValue = m * currentTimeSeconds + b;
        }
        // Clamp expected value to bounds (works for both positive and negative slope)
        expectedValue = Math.max(Math.min(expectedValue, maxBound), minBound);
        expectedValues.push(expectedValue);
        // Calculate threshold lines (works for both positive and negative slope)
        const upper = Math.min(expectedValue + data.threshold, maxBound);
        const lower = Math.max(expectedValue - data.threshold, minBound);
        upperThreshold.push(upper);
        lowerThreshold.push(lower);
    }
    // Actual data points (only those after enabled time)
    const actualTimes = [];
    const actualValues = [];
    const actualColors = [];
    const actualTooltips = [];
    const actualTimestamps = [];
    data.data_points.forEach(point => {
        if (point.timestamp) {
            const ptTime = parseAsUTC(point.timestamp);
            if (ptTime >= startTime) { // Only after enabled time
                actualTimes.push(toLocalISOString(ptTime));
                actualTimestamps.push(ptTime.getTime()); // For regression
                actualValues.push(point.value);
                // Determine if point is within bounds (matching trial.py logic)
                const currentTimeSeconds = ptTime.getTime() / 1000;
                let expectedValue;
                if (currentTimeSeconds < startTimeSeconds) {
                    expectedValue = data.start_value;
                } else if (currentTimeSeconds >= startTimeSeconds + timeToAchieve) {
                    expectedValue = data.target_value;
                } else {
                    expectedValue = m * currentTimeSeconds + b;
                }
                // Clamp expected value to bounds (works for both positive and negative slope)
                expectedValue = Math.max(Math.min(expectedValue, maxBound), minBound);
                const deviation = Math.abs(point.value - expectedValue);
                // Pass/fail logic for both positive and negative slope
                let inBounds;
                if (data.start_value < data.target_value) {
                    inBounds = deviation <= data.threshold && point.value <= data.target_value;
                } else {
                    inBounds = deviation <= data.threshold && point.value >= data.target_value;
                }
                actualColors.push(inBounds ? 'green' : 'red');
                actualTooltips.push(`Value: ${point.value}<br>Time: ${ptTime.toLocaleString()}<br>Expected: ${expectedValue.toFixed(2)}<br>Status: ${inBounds ? 'Pass' : 'Fail'}`);
            }
        }
    });

    // Helper: calculate linear regression (least squares)
    function linearRegression(x, y) {
        const n = x.length;
        if (n < 2) return null;
        const xMean = x.reduce((a, b) => a + b, 0) / n;
        const yMean = y.reduce((a, b) => a + b, 0) / n;
        let num = 0, den = 0;
        for (let i = 0; i < n; i++) {
            num += (x[i] - xMean) * (y[i] - yMean);
            den += (x[i] - xMean) ** 2;
        }
        const m = den === 0 ? 0 : num / den;
        const b = yMean - m * xMean;
        return { m, b };
    }

    // Calculate best fit line for all visible points
    let bestFitTrace = null;
    let bestFitEquation = '';
    if (actualTimestamps.length >= 2) {
        const reg = linearRegression(actualTimestamps, actualValues);
        if (reg) {
            // For display, use the visible x range
            const minX = Math.min(...actualTimestamps);
            const maxX = Math.max(...actualTimestamps);
            const fitX = [minX, maxX];
            const fitY = fitX.map(x => reg.m * x + reg.b);
            bestFitTrace = {
                x: fitX.map(x => toLocalISOString(new Date(x))),
                y: fitY,
                mode: 'lines',
                name: 'Best Fit',
                line: {color: 'red', width: 2, dash: 'dot'},
                hoverinfo: 'skip',
                showlegend: true
            };
            // Equation: y = m x + b, but x is time (ms), so show as y = m t + b
            // Convert slope to per hour if range is large, else per second
            let mDisp = reg.m;
            let mUnit = 'per ms';
            if (maxX - minX > 2 * 3600 * 1000) { // >2 hours
                mDisp = reg.m * 3600 * 1000;
                mUnit = 'per hour';
            } else if (maxX - minX > 2 * 60 * 1000) { // >2 min
                mDisp = reg.m * 60 * 1000;
                mUnit = 'per min';
            } else {
                mDisp = reg.m * 1000;
                mUnit = 'per sec';
            }
            bestFitEquation = `y = ${mDisp.toFixed(3)} t (${mUnit}) + ${reg.b.toFixed(2)}`;
        }
    }
    // Calculate expected line equation (y = mx + b)
    let expectedM = m;
    let expectedB = b;
    // For display, convert m to per second, per min, or per hour
    let expectedMDisp = expectedM;
    let expectedMUnit = 'per ms';
    if (timeToAchieve > 2 * 3600) { // >2 hours
        expectedMDisp = expectedM * 3600;
        expectedMUnit = 'per hour';
    } else if (timeToAchieve > 2 * 60) { // >2 min
        expectedMDisp = expectedM * 60;
        expectedMUnit = 'per min';
    } else {
        expectedMDisp = expectedM;
        expectedMUnit = 'per sec';
    }
    const expectedEquation = `y = ${expectedMDisp.toFixed(3)} t (${expectedMUnit}) + ${expectedB.toFixed(2)}`;

    // Plotly traces
    const traces = [
        {
            x: timePoints,
            y: expectedValues,
            mode: 'lines',
            name: `Expected (${expectedEquation})`,
            line: {color: 'blue', width: 2}
        },
        {
            x: timePoints,
            y: upperThreshold,
            mode: 'lines',
            name: 'Upper Threshold',
            line: {color: 'orange', width: 1, dash: 'dash'}
        },
        {
            x: timePoints,
            y: lowerThreshold,
            mode: 'lines',
            name: 'Lower Threshold',
            line: {color: 'orange', width: 1, dash: 'dash'}
        },
        // New: add a line connecting all actual data points
        {
            x: actualTimes,
            y: actualValues,
            mode: 'lines+markers',
            name: 'Actual (Line)',
            line: {color: '#888', width: 2, dash: 'solid'},
            marker: {
                color: actualColors,
                size: 10,
                symbol: 'circle',
                line: {width: 1, color: '#333'}
            },
            text: actualTooltips,
            hoverinfo: 'text'
        },
        // Keep the original markers for color distinction
        {
            x: actualTimes,
            y: actualValues,
            mode: 'markers',
            name: 'Actual (Points)',
            marker: {
                color: actualColors,
                size: 10,
                symbol: 'circle',
                line: {width: 1, color: '#333'}
            },
            text: actualTooltips,
            hoverinfo: 'text',
            showlegend: false
        }
    ];
    if (bestFitTrace) {
        bestFitTrace.name = `Best Fit (${bestFitEquation})`;
        traces.push(bestFitTrace);
    }

    // Add 'Now' line if now is within the extended window
    if (now >= startTime && now <= endTime) {
        const nowISO = toLocalISOString(now);
        const allYValues = [...expectedValues, ...actualValues, ...upperThreshold, ...lowerThreshold];
        const yMin = allYValues.length > 0 ? Math.min(...allYValues) : data.start_value;
        const yMax = allYValues.length > 0 ? Math.max(...allYValues) : data.target_value;
        
        traces.push({
            x: [nowISO, nowISO],
            y: [yMin, yMax],
            mode: 'lines',
            name: 'Now',
            line: {color: 'red', width: 2, dash: 'dot'},
            hoverinfo: 'skip',
            showlegend: true
        });
    }
    // Layout
    const layout = {
        title: '',
        xaxis: {
            title: 'Time',
            zeroline: false,
            showgrid: true,
            automargin: true,
            type: 'date', // Use date axis for time
        },
        yaxis: {
            title: 'Value',
            zeroline: false,
            showgrid: true,
            automargin: true
        },
        legend: {orientation: 'h', x: 0.5, xanchor: 'center', y: 1.15},
        margin: {l: 60, r: 30, t: 30, b: 60},
        hovermode: 'closest',
        dragmode: 'pan',
        autosize: true,
        annotations: [
            bestFitEquation ? {
                xref: 'paper', yref: 'paper',
                x: 0.99, y: 0.01,
                xanchor: 'right', yanchor: 'bottom',
                text: bestFitEquation,
                showarrow: false,
                font: {size: 13, color: 'red'}
            } : null,
            expectedEquation ? {
                xref: 'paper', yref: 'paper',
                x: 0.01, y: 0.01,
                xanchor: 'left', yanchor: 'bottom',
                text: expectedEquation,
                showarrow: false,
                font: {size: 13, color: 'blue'}
            } : null
        ].filter(Boolean)
    };
    // Config
    const config = {
        responsive: true,
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToAdd: ['zoom2d', 'pan2d', 'resetScale2d', 'toImage', 'autoScale2d', 'select2d', 'lasso2d', 'toggleSpikelines', 'zoomIn2d', 'zoomOut2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'toggleHover'],
        toImageButtonOptions: {
            format: 'png',
            filename: 'diagnostic_graph',
            height: 600,
            width: 1000,
            scale: 2
        }
    };
    // Before drawing, update trace visibility from state
    traces.forEach((trace, i) => {
        const name = trace.name || `Trace ${i+1}`;
        if (window.traceVisibilityState[name] === false) {
            trace.visible = 'legendonly';
        } else {
            trace.visible = true;
        }
    });

    // Add custom legend container to the right of the graph
    let legendDiv = document.getElementById('customLegend');
    if (!legendDiv) {
        legendDiv = document.createElement('div');
        legendDiv.id = 'customLegend';
        legendDiv.style.position = 'absolute';
        legendDiv.style.top = '60px';
        legendDiv.style.right = '10px';
        legendDiv.style.width = '180px';
        legendDiv.style.background = '#fff';
        legendDiv.style.border = '1px solid #ddd';
        legendDiv.style.borderRadius = '8px';
        legendDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.07)';
        legendDiv.style.padding = '12px 10px 12px 10px';
        legendDiv.style.zIndex = '2000';
        legendDiv.style.fontSize = '14px';
        legendDiv.style.maxHeight = '70vh';
        legendDiv.style.overflowY = 'auto';
        legendDiv.innerHTML = '<b>Show/Hide:</b><br/>';
        container.parentElement.appendChild(legendDiv);
    } else {
        legendDiv.innerHTML = '<b>Show/Hide:</b><br/>';
    }

    // Helper: get trace names and colors
    function getTraceInfo(traces) {
        return traces.map((t, i) => ({
            name: t.name || `Trace ${i+1}`,
            color: t.line?.color || t.marker?.color || '#333',
            index: i
        }));
    }

    // Generate checkboxes for each trace
    const traceInfo = getTraceInfo(traces);
    traceInfo.forEach(trace => {
        const id = `legend-checkbox-${trace.index}`;
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.marginBottom = '6px';
        label.style.cursor = 'pointer';
        label.htmlFor = id;
        const box = document.createElement('input');
        box.type = 'checkbox';
        box.id = id;
        // Set checked state from global visibility state
        box.checked = window.traceVisibilityState[trace.name] !== false;
        box.style.marginRight = '8px';
        // Color dot
        const dot = document.createElement('span');
        dot.style.display = 'inline-block';
        dot.style.width = '14px';
        dot.style.height = '14px';
        dot.style.borderRadius = '50%';
        dot.style.background = Array.isArray(trace.color) ? trace.color[0] : trace.color;
        dot.style.marginRight = '8px';
        label.appendChild(box);
        label.appendChild(dot);
        label.appendChild(document.createTextNode(trace.name));
        legendDiv.appendChild(label);
        // Toggle trace visibility
        box.addEventListener('change', function() {
            window.traceVisibilityState[trace.name] = this.checked;
            Plotly.restyle(container, {visible: this.checked ? true : 'legendonly'}, [trace.index]);
        });
    });

    // Use Plotly.react for smooth updates
    Plotly.react(container, traces, layout, config);
    
    // --- Fullscreen legend support ---
    // Helper to move legend in/out of fullscreen
    function moveLegendToFullscreen(isFullscreen) {
        const legend = document.getElementById('customLegend');
        if (!legend) return;
        if (isFullscreen) {
            // Move legend into fullscreen element
            const fsElem = document.fullscreenElement;
            if (fsElem && !fsElem.contains(legend)) {
                fsElem.appendChild(legend);
                legend.style.position = 'fixed';
                legend.style.top = '60px';
                legend.style.right = '30px';
            }
        } else {
            // Move legend back to graph container's parent
            const graphParent = container.parentElement;
            if (graphParent && !graphParent.contains(legend)) {
                graphParent.appendChild(legend);
                legend.style.position = 'absolute';
                legend.style.top = '60px';
                legend.style.right = '10px';
            }
        }
    }
    // Listen for fullscreen changes
    document.removeEventListener('fullscreenchange', window._legendFSHandler);
    window._legendFSHandler = function() {
        moveLegendToFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', window._legendFSHandler);
    
    // Add dynamic best fit update on zoom/pan/autoscale/reset
    container.on('plotly_relayout', function(eventdata) {
        let xRange = null;
        if (eventdata['xaxis.range[0]'] && eventdata['xaxis.range[1]']) {
            // Zoom or pan
            xRange = [new Date(eventdata['xaxis.range[0]']).getTime(), new Date(eventdata['xaxis.range[1]']).getTime()];
        } else if (eventdata['xaxis.autorange']) {
            // Autoscale or reset axes: use full range
            if (actualTimestamps.length >= 2) {
                xRange = [Math.min(...actualTimestamps), Math.max(...actualTimestamps)];
            }
        }
        if (!xRange) return;
        // Filter points in view
        const inView = actualTimestamps.map((t, i) => (t >= xRange[0] && t <= xRange[1]) ? i : -1).filter(i => i !== -1);
        if (inView.length < 2) return;
        const x = inView.map(i => actualTimestamps[i]);
        const y = inView.map(i => actualValues[i]);
        const reg = linearRegression(x, y);
        if (!reg) return;
        const fitX = [Math.min(...x), Math.max(...x)];
        const fitY = fitX.map(xx => reg.m * xx + reg.b);
        const newBestFit = {
            x: fitX.map(xx => toLocalISOString(new Date(xx))),
            y: fitY,
            mode: 'lines',
            name: `Best Fit (${bestFitEquation})`,
            line: {color: 'red', width: 2, dash: 'dot'},
            hoverinfo: 'skip',
            showlegend: true
        };
        // Equation for annotation
        let mDisp = reg.m;
        let mUnit = 'per ms';
        if (fitX[1] - fitX[0] > 2 * 3600 * 1000) {
            mDisp = reg.m * 3600 * 1000;
            mUnit = 'per hour';
        } else if (fitX[1] - fitX[0] > 2 * 60 * 1000) {
            mDisp = reg.m * 60 * 1000;
            mUnit = 'per min';
        } else {
            mDisp = reg.m * 1000;
            mUnit = 'per sec';
        }
        const eqn = `y = ${mDisp.toFixed(3)} t (${mUnit}) + ${reg.b.toFixed(2)}`;
        // Replace best fit trace and annotation
        const newTraces = traces.filter(t => !t.name.startsWith('Best Fit'));
        newTraces.push(newBestFit);
        const newLayout = {...layout, annotations: [
            {
                xref: 'paper', yref: 'paper',
                x: 0.99, y: 0.01,
                xanchor: 'right', yanchor: 'bottom',
                text: eqn,
                showarrow: false,
                font: {size: 13, color: 'red'}
            },
            expectedEquation ? {
                xref: 'paper', yref: 'paper',
                x: 0.01, y: 0.01,
                xanchor: 'left', yanchor: 'bottom',
                text: expectedEquation,
                showarrow: false,
                font: {size: 13, color: 'blue'}
            } : null
        ].filter(Boolean)};
        Plotly.react(container, newTraces, newLayout, config);
    });
    
    // Store the data for incremental updates
    lastGraphData = data;
}

function updateGraphWithNewData(newData) {
    if (!lastGraphData || !currentGraphModal) return;
    
    const container = document.getElementById('graphContainer');
    if (!container) return;
    
    // Find new data points that weren't in the previous data
    const existingTimestamps = new Set(lastGraphData.data_points.map(p => p.timestamp));
    const newPoints = newData.data_points.filter(p => !existingTimestamps.has(p.timestamp));
    
    console.log('New points found:', newPoints.length);
    console.log('Total points in new data:', newData.data_points.length);
    console.log('Total points in last data:', lastGraphData.data_points.length);
    
    if (newPoints.length === 0) {
        // No new points, just update the "Now" line
        updateNowLine(newData);
        return;
    }
    
    // For now, let's just recreate the entire graph with new data
    // This is simpler and more reliable
    createGraph(newData, currentGraphModal);
    
    // Store updated data
    lastGraphData = newData;
}

function updateNowLine(newData) {
    // For now, this will be handled by the full graph recreation
    console.log('updateNowLine called');
}
</script>
{% endblock %} 